---
title: 第2章 信息的表示和处理:用01表达整个世界
date: 2017-07-16 15:20:12
tags: 深入理解计算机系统(第三版) 读书笔记
---
### 1. 概述
从程序员的角度来看计算机中的数据类型，对于绝大多数语言而言，基本上都会有`整数`、`浮点数`、`字符串`和`二进制串`这几种数据类型，但在计算机系统中，如果追溯到最底层，这些不同种类的`信息`的表示，都会归结为最简单的`01`串的有限组合：

    0101010101010010101010101111111000111111000011111110001111000100000101001111111111010110101011111111110100001010101100001000101010

在最底层的计算机硬件实现里，`1`一般会用一个高电平或者脉冲表示，而`0`则会用一个低电平或者脉冲表示，回忆一下大学里学的随便一个简单的电子芯片，比如`3-8译码器`你去翻它的[Datas sheet](http://www.alldatasheet.com/view.jsp?Searchword=74LS138)，就会在最底层的计算机硬件里，发现`01`的真实身份就是一个个具体的`电信号`，信息的`存储、传送、加工`，最终、也是最真实的面目就是这些电信号流在`CPU、内存、外存、乃至网络`中的`游走、转移和各种位级的运算`，这些底层的`电信号`的活动，被一层层的`抽象`、`汇聚`成`更高级`、`也更复杂`的计算机软硬件理论及知识体系。

`深入理解计算机系统`这本书的最终目的就是这些`01`串所组成的大千世界的具体轮廓给讲清楚，其方式是最简单的至底向上的逐层讲解。而在`本章`，则关注的就是最底层的`01`信号具体是如何抽象表示更高一层的各种`基础数据类型`和`基础数据操作`的。

本章共5小节，除去最后一小节的总结内容，前四节分别介绍了`信息存储`、`整数表示`、`整数运算`和`浮点数`，从全章的目录来看，本章的内容非常清晰，就是计算机底层的`01`串是`如何存储`、`如何表示`的。更数学一点的概括，就是介绍了几个转换函数，输入是计算机所擅长的`01`二进制串，输出是我们所熟悉的`十进制数`，以及如果通过`二进制的算术九三以及逻辑操作`来**模拟实现**`十进制数中的算术计算以及逻辑操作`。这几种`函数`的特点是：
- 输入都是`01`二进制串
- 输出则是符合各种意义和模式的`基础数据类型`
函数体如下：
$$ y = f(x), x=0101010, y = int, char, float...$$
本章的内容就是介绍了这么几种转换函数$ f(x)$。
### 2. 信息的表示所带来的问题
在讲具体的函数之前，首先要明白信息是如何在计算机中存储的：大多数的计算使用8位的块（`byte`，以后统称为**字节**），作为`最小的可寻址`的内存单元：

    10010110

程序数据、指令和控制信息，都是由这些`bytes`的组装起来的，对于多**字节**的数据类型来说，就有一个`字节序`如何存储和解析的问题：这就是著名的[大小端](https://en.wikipedia.org/wiki/Endianness)问题。

在将一个`多字节`表示的`程序对象`存储到连续的`地址空间`的时候，我们必然要面临两个问题：
- 这个对象的地址是什么？
- 在内存中如何排列这些字节？
在几乎所有机器上，这两个问题的答案都将是：
- 多字节都被存储为连续的字节序列，对象的地址为**所使用字节中最小的地址**；
- 对于大多数`Intel`兼容机都只用小端模式，而许多新的微处理器的大小端是可选的，也即所谓的`bi-endian`，比如`ARM`微处理器，但有意思的是运行于其上的两种最流行的`Android`和`iOS`却只能运行于小端模式；
- 在网络中进行的传送的`字节序`都统一使用`大端模式`，这是事实上的网络协议簇`TCP/IP`中明确指定的。

为了更好的理解`大小端`，我们以一个简单的32位整形变量的存储来说明问题，为了便于表示，我们采用`十六进制`：

    int32_t dog = 0x99887700

数学常识告诉我们`99`是最高字节，`00`是最低字节，这种排列是`从左到右`按照`从高字节到低字节`的顺序排列的，这里的`高字节`就意味着其拥有更高的`权重`或者：`power`，这种排列顺序就是所谓的`字节序`。而当我们要将其存储到内存中的时候，我们又将遇到`地址序`这一概念，其实很简单，就是内存中的所有地址都是按照`从低到高`的顺序进行编址的：比如我们常说的`32位机`它的`寻址空间`是$0$到$2^{32} - 1$，也就是`4GB`大小，这些地址都是按照`0`到`最高位`排列的。

仍以上文中的`32 bit`长度的`dog`变量为例，假设其内存中的地址为`0x324580`，由**最小寻址单元**为`byte`也即`8 bit`我们可知，`dog`将占用`4 字节`的内存空间，那么这`4字节`该如何存储呢？答案是可见下图：

图中地址从下往上增长，在**小端系统**中地址由低到高分别存储的是`00 77 88 99`，即**低地址存低字节**，而**大端系统**则刚好相反：地址由低到高分别存储的是`99 88 77 00`，即**低地址存高字节**。这就是**大小端**的最本质区别。

| 地址      |     存储值（小端系统：如绝大多数系统） |存储值（大端系统：如网络字节序） | 
| :-------- | --------:|  --------:| 
| 0xffffffff    |   * |    * | 
| 0xfffffffe    |   * |    * | 
| 0xfffffffd    |   * |    * | 
| ......    |   * |    * | 
| ......    |   * |    * | 
| 0x08324532    |   * |    * | 
| ......    |   * |    * | 
| 0x01324583    |   0x99|    0x00| 
| 0x01324582    |   0x88|    0x77| 
| 0x01324581    |   0x77 |    0x88 | 
| 0x01324580    |   0x00 |    0x99| 
| ......    |   * |    * | 
| 0x00000010    |   * |    * | 
| 0x00000001    |   * |    * | 
| 0x00000000    |   * |    * | 
### 3.整数的表示
### 3.1无符号整数（正整数和0）
在我们上小学的一二年级的时候，我们的数学世界是非常干净的：没有小数、没有负数，更不用提无理数了，那个时候我们以为仅仅是**正整数**就足以表达整个世界，后来我们发现，是我们太幼稚了，这个世界太复杂，复杂到必须要造出那么多复杂的数才够用。
计算机世界里的**抽象**都是对真实世界的**模拟**，因此这种**抽象**必须要包含各种复杂的**数**，同样的，我们先从最简单（至少是看上去最简单）的整数的表示讲起，我们这里约定计算机世界里用一个`32 bit`的内存来存放一个**整数**。我们来看看如何用这`32 bit`内存空间来存储和表示**正整数（也即无符号数）**和**整数**：

根据前文介绍的，整数的表示，实际上就是定义一个函数，输入为`32 位`二进制序列（因为这里我们假定只使用`32 bit`来表示整数），这里我们引入数学中向量的概念来表示这个输入的二进制序列：
$$\vec x = [x_{w-1},x_{w-2},...,x_{0}]，w = 32, x_i = {0, 1}$$
那么向量$\vec x $的值一共有$2^{w}, w=32$，因此每一个值都可以实际表示一个整数（或者浮点数），剩下的就是定义编码函数对这些值做映射了：

| $\vec x $      | 
| :--------: | 
| $[11111111,11111111,11111111,11111111]$    | 
| $[11111111,11111111,11111111,11111110]$    | 
| $[11111111,11111111,11111111,11111101]$    | 
|......|
|......|
| $[00011111,01000011,00011011,11111101]$   | 
|......|
|......|
|$000000000,00000000,00000000,00000011$|
|$000000000,00000000,00000000,00000010$|
|$000000000,00000000,00000000,00000001$|
|$000000000,00000000,00000000,00000000$|
如果全部列全，则上面这个表格将会有$2^{32}$列，也即`4 294 967 296`列！约`42.9`亿列，马云爸爸的银行卡账户如果用这个`32`位的整形表示则肯定是要溢出的！^_^，年前王健林曾说要先定一个小目标，**比如说先赚它一个亿**，那对于码农的我来说，我也定个小目标：**10年以后，我的银行卡余额要让w位 $\vec x$ 表示的无符号整数产生溢出** ^_^，但问题是这个`w`会是多少呢？
则**无符号数**的编码函数可以定义为（`B2U == Binary to Unsigned Integer`）：
$$y = f(\vec x) = B2U_w(\vec x) \stackrel{·}{=} \sum_{i=0}^{w-1}x_i2^i, w = 32, x_i = {0, 1}$$
数学公式的魅力就是非常简洁、精确的表达了某种确定的函数关系，比如上面这个公式，就一行，就说明了一切。但数学公式简洁的同时，却又不够直观，可能有些人看了半天才明白，而另外一些人则始终看不明白^_^。好吧，让我们来直观一些用图说话：

**无符号数**的编码函数$B2U_w(\vec x)$产生的映射结果是：
![|center|500x0](http://ot6o6xw2z.bkt.clouddn.com/csapp_ch2_1@2x.png)
 图-1`32`位二进制数表示的无符号整数映射表 
### 3.整数（负整数、正整数和0）
在上一小节中我们知道，`32 bit`的二进制序列的所有组合是一个有限集合，集合中元素的个数是 $ 2^{32} $，它所能表示的**无符号整数**的范围也刚好是$2^{32}$个，那么现在要用这$2^{32}$个元素表示**整数**，那么显然，依然是只能表示最多$2^{32}$个整数集合，但是整数还包含有**负数**，那么直觉告诉我们，它所能表示的**整数**肯定会减半的，事实上也正是如此。不过比较尴尬的是，现在能表示的整数个数是偶数，但我们又刚好又一个`0`既非**正整数**，也不是**负整数**，那么剩下的$2^{32}-1$个元素所能表示的**正整数**和**负整数**的个数必然不是相等的**（除非0也用两个元素表示，分表为$\stackrel{+}{-}0$，实际上还真有这么表示的）**，一个为$2^{31}$另外一个为$2^{31}-1$，由此，很自然的我们就能推导出：**最大正整数和最大负整数的绝对值是不相等的！**。

为了简化我们的**整数表示**的推演，我们这里讲前面的`32 bit`二进制流再进一步简化为`4 bit`，那么在这种情况下，所能表示的无符号整数有`0`到`15`，共`16`个，全部集合见下图：

![|center|0x400](http://ot6o6xw2z.bkt.clouddn.com/csapp_ch2_2@2x.png)
 图-2 四位二进制数表示的无符号整数集合映射关系图 

现在我们想要用同样的`16`个二进制集合表示`整数`，那么显然我们就被迫要从这表示的**无符号整数**中**挤掉**`7`个或者`8`个**正整数**用以表示**负整数**，那么显然为了保持表示**整数值域**的**连续性**，我们剔除掉`8~15`共`8`位来表示**负数或者-0**，但是问题又来了，这剩下的`8`位该如何表示**负数**？我们不妨脑洞大开，自己设计一下吧，能想到的至少有四种方案：

![|center|0x400](http://ot6o6xw2z.bkt.clouddn.com/csapp_ch2_3@2x.png)
 图-3 四位二进制数表示的整数集合映射关系方案1&2 


![|center|0x400](http://ot6o6xw2z.bkt.clouddn.com/csapp_ch2_4@2x.png)
 图-4 四位二进制数表示的整数集合映射关系方案3&4 


事实上映射方案远不止这些，如果我们让正整数的映射位置不和无符号整数的映射位置保持一致的话，我们还可以这样映射：将无符号整数的映射关系整体上移（-8）如图：

![|center|0x400](http://ot6o6xw2z.bkt.clouddn.com/csapp_ch2_5@2x.png)

图-5 将无符号整数的映射关系整体上移

这五种编码方案，我们很容易写出他们的映射函数：

**Case1**：
$$y = f(\vec x) = B2X_w(\vec x) \stackrel{·}{=} -x_{w-1}(2^{w-1}-2) + \sum_{i=0}^{w-2}x_i2^i, w = 32, x_i = {0, 1}$$

**Case2**：
$$y = f(\vec x) = B2S_w(\vec x) \stackrel{·}{=} (-1)^{w-1}· \sum_{i=0}^{w-2}x_i2^i, w = 32, x_i = {0, 1}$$

**Case3**：
$$y = f(\vec x) = B2O_w(\vec x) \stackrel{·}{=} -x_{w-1}(2^{w-1}-1) + \sum_{i=0}^{w-2}x_i2^i, w = 32, x_i = {0, 1}$$

**Case4**：
$$y = f(\vec x) = B2T_w(\vec x) \stackrel{·}{=} -x_{w-1}·2^{w-1} + \sum_{i=0}^{w-2}x_i2^i, w = 32, x_i = {0, 1}$$

**Case5**：
$$y = f(\vec x) = B2Y_w(\vec x) \stackrel{·}{=} -2^{w-1} +\sum_{i=0}^{w-1}x_i2^i, w = 32, x_i = {0, 1}$$
在这列举的5中方案中，有3套方案是计算机系统中的**标准表示方法**，但只有一种是**事实上的标准**被几乎所有计算机系统采用：

| Case      |     对应命名 |   说明   |优缺点|
| :--------: | :--------:| :------: |:------: |
| 2    |   原码（Sign-Magnitude） |  整数编码中未采用，浮点数采用  |正负对称，但是有正负0|
|3|反码（Ones'Complement）|过去存在过反码表示的机器，但现在已经绝迹|正负对称，但是有正负0|
|4|补码（Two's Complement）|广泛采用，事实上的标准|0只有一种表示，但是正负不对称|
关于补码和反码中`'`的位置及其定义说明：**Two's Complement**来自于：对于非负数$x$,我们用$2^w - x$来计算$-x$的表示，这里有一个$2$，所以是`Two's`；但对于补码，则是用$[111···1]-x$来计算补码表示，这里有很多个$1$，所以是`Ones'`。其实对于这两种编码的记忆，我们也可以从其英文名称中得到启发：

补码，**Two's Complement**，对于任意的整数`x`其`w`位的补码值和其相反数`-x`的补码表示值相加刚好是到$2^w$，而反码**Ones's Complement**表示的`x`和其相反数相加的值则是$2^w - 1$（也就是`w`位全是`1`）。
